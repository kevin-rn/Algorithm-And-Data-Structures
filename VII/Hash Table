import java.util.*;

/**
 * Entry objects are used to represent "Key-Value" pairs.
 * An entry can be created by using new Entry(String key, Integer Value)
 * The .equals() method of Entry will compare the keys only.
 */
class Entry {
  public final String key;
  public final Integer value;

  public Entry(String s, Integer v) {
    key = s;
    value = v;
  }

  public boolean equals(String s) {
    return s == null && key == null || key.equals(s);
  }

  @Override
  public boolean equals(Object o) {
    return (this == o) || (o != null && getClass() == o.getClass() && this.equals(((Entry) o).key));
  }

  public String getKey() {
    return key;
  }

  public int getValue() {
    return value;
  }
}

abstract class HashTable {
  protected LinkedList<Entry>[] myTable;

  /**
   * Constructs a new HashTable.
   *
   * @param capacity
   *     to be used as capacity of the table.
   * @throws IllegalArgumentException
   *     if the input capacity is invalid.
   */
  @SuppressWarnings("unchecked")
  public HashTable(int capacity) {
    if(capacity <= 0) throw new IllegalArgumentException();
    else myTable = new LinkedList[capacity];
  }

  /**
   * Add a key value pair to the HashTable.
   *
   * @param key
   *     to identify the value.
   * @param value
   *     that is identified by the key.
   */
  public void put(String key, Integer value) {
     if (myTable != null) {
            int hash = hash(key);
            if (myTable[hash] == null) {
                myTable[hash] = new LinkedList<>();
            }
            if (containsKey(key)) {
                for (int i = 0; i < myTable[hash].size(); i++) {
                    Entry entry = myTable[hash].get(i);
                    if (entry.equals(key)) {
                        myTable[hash].set(i, new Entry(key, value));
                    }
                }
            } else {
                myTable[hash].add(new Entry(key, value));
            }
        }
  }

  /**
   * @param key
   *     to look for in the HashTable.
   * @return true iff the key is in the HashTable.
   */
  public boolean containsKey(String key) {
    if(myTable != null){
        int hashed = hash(key);
        if(myTable[hashed] != null){
          for(Entry en : myTable[hashed]){
            if(en.equals(key)){ return true;}}
        }}
    return false;
  }

  /**
   * Get a value from the HashTable.
   *
   * @param key
   *     that identifies the value.
   * @return the value associated with the key or `null` if the key is not in the HashTable.
   */
  public Integer get(String key) {
    if(containsKey(key)){
      int hashed = hash(key);
      for(Entry entry : myTable[hashed])
        if(entry.equals(key)) return entry.getValue();
    }
    return null;
  }

  /**
   * @return the capacity of the HashTable.
   */
  public int getCapacity() {
    return myTable.length;
  }

  /**
   * Hashes a string/key.
   *
   * @param item
   *     to hash.
   * @return the hashcode of the string, modulo the capacity of the HashTable.
   */
  public abstract int hash(String item);
}
/*
Implement the methods of the abstract Hashtable class, which uses an array of LinkedLists to hold its data. See the JavaDoc for the available methods on LinkedList.

You are expected to implement the following methods:

HashTable(int size)     // (the constructor)
void put(String key, Integer value) 
containsKey(String key) 
int get(String key)

Check the JavaDoc comments to see what each method is supposed to do.

You should use the abstract int hash to determine where an entry should be put in the array of LinkedLists. You do not have to implement this method.

The HashTable should allow keys that are null to be added to the table.

*/
